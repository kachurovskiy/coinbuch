<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>coinbuch</title>
  <link rel="icon" href="data:,">
  <script type="module" crossorigin>
var A=Object.defineProperty;var B=(r,e,t)=>e in r?A(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t;var C=(r,e,t)=>(B(r,typeof e!="symbol"?e+"":e,t),t);(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))n(s);new MutationObserver(s=>{for(const i of s)if(i.type==="childList")for(const u of i.addedNodes)u.tagName==="LINK"&&u.rel==="modulepreload"&&n(u)}).observe(document,{childList:!0,subtree:!0});function t(s){const i={};return s.integrity&&(i.integrity=s.integrity),s.referrerPolicy&&(i.referrerPolicy=s.referrerPolicy),s.crossOrigin==="use-credentials"?i.credentials="include":s.crossOrigin==="anonymous"?i.credentials="omit":i.credentials="same-origin",i}function n(s){if(s.ep)return;s.ep=!0;const i=t(s);fetch(s.href,i)}})();const x=["Advanced Trade Buy","Receive"],w=["Advanced Trade Sell","Send"],E=w.concat(["Withdrawal"]),W=x.concat(["Deposit","Reward Income","Subscription Rebate","Subscription Rebates (24 Hours)"]),Y=["Advanced Trade Buy","Advanced Trade Sell","Deposit","Receive","Reward Income","Send","Subscription Rebate","Subscription Rebates (24 Hours)","Withdrawal"],T=["AUD","CAD","CHF","CNY","EUR","GBP","HKD","JPY","KRW","NZD","SGD","USD"],H=new Map([["AUD","A$"],["CAD","C$"],["CHF","CHF"],["CNY","¥"],["EUR","€"],["GBP","£"],["HKD","$"],["JPY","¥"],["KRW","₩"],["NZD","NZ$"],["SGD","SGD"],["USD","$"]]),v=["USDC","USDT"],J=1e-7;class l{constructor(e,t){C(this,"amount");C(this,"currency");this.amount=e,this.currency=t}toString(){return this.toFixed(2)}plus(e){if(this.currency!==e.currency)throw new Error(`Cannot add ${this.currency} and ${e.currency}`);return new l(this.amount+e.amount,this.currency)}minus(e){if(this.currency!==e.currency)throw new Error(`Cannot subtract ${this.currency} and ${e.currency}`);return new l(this.amount-e.amount,this.currency)}multiply(e){return new l(this.amount*e,this.currency)}convert(e,t,n){const s=n||t.targetCurrency;if(this.currency===s)return this;const i=e.toISOString().split("T")[0],u=t.getExchangeRateFromUSD(i);if(u===void 0)throw new Error(`Exchange rate for ${s} at ${i} not found`);if(this.currency==="USD")return new l(this.amount*u,s);if(s==="USD"&&this.currency===t.targetCurrency)return new l(this.amount/u,s);throw new Error(`Cannot convert ${this.currency} to ${s}`)}toFixed(e){return this.amount?this.amount.toFixed(e)+y(this.currency):""}}async function K(r,e,t){if(r==="USD")return{targetCurrency:"USD",convertFromUSD:c=>c,getExchangeRateFromUSD:()=>1};const n=`exchangeRates-${r}`,s=JSON.parse(localStorage.getItem(n)||"{}"),u=Array.from(new Set(e.map(c=>c.time.toISOString().split("T")[0]))).filter(c=>!(c in s));try{for(const c of u){const a=`https://api.coinbase.com/v2/prices/${r}-USD/spot?date=${c}`,o=await fetch(a);if(!o.ok)throw new Error(`HTTP error! status: ${o.status}`);const d=await o.json(),m=parseFloat(d.data.amount);s[c]=m,t(`Fetched exchange rate for ${c}: ${m}`),localStorage.setItem(n,JSON.stringify(s))}}catch(c){throw console.error("Error fetching exchange rates:",c),new Error("Failed to fetch exchange rates")}return{targetCurrency:r,convertFromUSD:(c,a)=>{const o=a.toISOString().split("T")[0],d=s[o];if(d===void 0)throw new Error(`Exchange rate for ${o} not found`);return parseFloat((c/d).toFixed(2))},getExchangeRateFromUSD:c=>1/s[c]}}function y(r){return H.get(r)||r}function Z(r,e){for(const t of r)if(t.priceCurrency!==e&&t.asset!==e)return!0;return!1}function Q(r,e){return r.time.getFullYear()<2e3||r.time.getFullYear()>2100?`Invalid year ${r.time.getFullYear()} in row ${JSON.stringify(e)}`:Y.includes(r.type)?isNaN(r.quantity)?`Invalid quantity ${r.quantity} in row ${JSON.stringify(e)}`:isNaN(r.price.amount)||r.price.amount<0?`Invalid price ${r.price} in row ${JSON.stringify(e)}`:isNaN(r.fee.amount)||r.fee.amount<0?`Invalid fee ${r.fee} in row ${JSON.stringify(e)}`:isNaN(r.subtotal.amount)?`Invalid subtotal ${r.subtotal} in row ${JSON.stringify(e)}`:isNaN(r.total.amount)?`Invalid total ${r.total} in row ${JSON.stringify(e)}`:"":`Invalid transaction type ${r.type} in row ${JSON.stringify(e)}`}function j(r,e){const t=r.subtotal.plus(r.fee.multiply(w.includes(r.type)?-1:1));if(t.amount>0&&Math.abs(1-r.total.amount/t.amount)>.001&&Math.abs(r.total.amount-t.amount)>1)return`Invalid total ${r.total} - expected ${t} in row ${JSON.stringify(e)}`;const n=Math.abs(r.price.amount*r.quantity);return r.quantity!==0&&Math.abs(1-n/r.subtotal.amount)>.002&&Math.abs(n-r.subtotal.amount)>1?`Invalid subtotal ${n} - expected ${r.subtotal} in row ${JSON.stringify(e)}`:""}function k(r){const e=r.split(`
`);for(;!e[0].startsWith("ID");)e.shift();const t=e[0].split(",");e.shift();const n=[];for(let s of e){if(s=s.trim(),!s)continue;const i=s.split(",");if(i.length!==t.length)throw new Error(`Invalid row: ${s}`);const u=new Map;u.set("raw",s);for(let c=0;c<t.length;c++){let a=i[c];a.startsWith('"')&&a.endsWith('"')&&(a=a.slice(1,-1)),u.set(t[c],a)}n.push(Object.fromEntries(u))}return n}function z(r){const e=k(r),t=[],n=[],s=[];for(const i of e){const u=i["Price Currency"];let c={raw:i.raw,id:i.ID,time:X(i.Timestamp),type:i["Transaction Type"],asset:i.Asset,quantity:g(i["Quantity Transacted"]),price:new l(g(i["Price at Transaction"]),u),priceCurrency:u,subtotal:new l(g(i.Subtotal),u),total:new l(g(i["Total (inclusive of fees and/or spread)"]),u),fee:new l(g(i["Fees and/or Spread"]),u),notes:i.Notes,quantitySold:0,gainOrLoss:new l(0,u),lossInFeesIncluded:new l(0,u)};c.asset==="USDC"&&c.priceCurrency==="USD"&&(c=V(c));const a=Q(c,i);if(a){n.push(a);continue}const o=j(c,i);o&&s.push(o),t.push(c)}return t.sort((i,u)=>i.time.getTime()-u.time.getTime()),{transactions:t,errors:n,warnings:s}}function V(r){const e=r.notes.match(/(Bought|Sold) ([0-9.]+) USDC for ([0-9.]+) ([A-Z]+) on ([A-Z]+-[A-Z]+) at ([0-9.]+) ([A-Z]+\/USDC)/);if(!e)return r;const t=g(e[2]),n=e[4],s=g(e[6]),i=new l(g(e[3]),n),u=new l(r.fee.amount*s,n);return{...r,quantity:t,price:new l(s,n),priceCurrency:n,fee:u,subtotal:i.minus(u),total:i}}function I(r){return["Quantity Transacted","Price at Transaction","Subtotal","Total (inclusive of fees and/or spread)","Fees and/or Spread"].includes(r)}function g(r){return r?Math.abs(parseFloat(r.replace(/\$/,""))):0}function X(r){if(!r)throw new Error("Invalid timestamp: "+r);const e=r.split(" ");if(e.length!==3)throw new Error(`Invalid timestamp: ${r}`);if(e[2]!=="UTC")throw new Error(`Invalid timezone: ${e[2]}`);const t=e[0].split("-"),n=e[1].split(":");return new Date(Date.UTC(parseInt(t[0]),parseInt(t[1])-1,parseInt(t[2]),parseInt(n[0]),parseInt(n[1]),parseInt(n[2])))}class _{render(e){const t=document.createElement("div");if(t.classList.add("sectionErrors"),e.file.errors.length){const n=document.createElement("h2");n.innerText="Errors",t.appendChild(n)}for(const n of e.file.errors){const s=document.createElement("div");s.innerText=n,s.classList.add("error"),t.appendChild(s)}if(e.file.warnings.length){const n=document.createElement("h2");n.innerText="Warnings",t.appendChild(n)}for(const n of e.file.warnings){const s=document.createElement("div");s.innerText=n,s.classList.add("warning"),t.appendChild(s)}return t}}class ee{constructor(e,t,n){this.model=e,this.year=t,this.transactions=n}render(){const e=document.createElement("div"),t=document.createElement("h3");t.innerText="Calendar year "+this.year,e.appendChild(t);const n=document.createElement("table");n.classList.add("yearSecurityTable"),e.appendChild(n);const s=document.createElement("thead");n.appendChild(s);const i=document.createElement("tr");s.appendChild(i);const u=["Security","First buy","Last sell","Gain "+y(this.model.exchange.targetCurrency)];for(const h of u){const p=document.createElement("th");p.innerText=h,I(h)&&p.classList.add("numeric"),i.appendChild(p)}const c=new Map;for(const h of this.transactions){const p=h.asset,f=c.get(p)||new l(0,this.model.exchange.targetCurrency),S=h.gainOrLoss.convert(h.time,this.model.exchange);c.set(p,f.plus(S))}const a=new Map,o=new Map;for(const h of this.transactions){const p=h.asset;if(x.includes(h.type)){const f=a.get(p);(!f||h.time.getTime()<f.getTime())&&a.set(p,h.time)}else if(w.includes(h.type)){const f=o.get(p);(!f||h.time.getTime()>f.getTime())&&o.set(p,h.time)}}for(const[h,p]of c){const f=document.createElement("tr");n.appendChild(f);const S=document.createElement("td"),$=document.createElement("a");$.innerText=h,$.href="#"+h,S.appendChild($),f.appendChild(S);const N=a.get(h),O=document.createElement("td");N&&(O.innerText=N.toISOString().split("T")[0]),f.appendChild(O);const R=o.get(h),U=document.createElement("td");R&&(U.innerText=R.toISOString().split("T")[0]),f.appendChild(U);const L=document.createElement("td");L.innerText=p.toFixed(2),L.classList.add(p.amount>0?"positive":"negative"),f.appendChild(L)}const d=Array.from(n.rows).slice(1);d.sort((h,p)=>h.cells[0].innerText.localeCompare(p.cells[0].innerText));for(const h of d)n.appendChild(h);const m=document.createElement("tr");m.classList.add("totalRow"),n.appendChild(m);const D=document.createElement("td");D.innerText="Total",m.appendChild(D),m.appendChild(document.createElement("td")),m.appendChild(document.createElement("td"));const b=document.createElement("td"),F=this.transactions.reduce((h,p)=>h.plus(p.gainOrLoss.convert(p.time,this.model.exchange)),new l(0,this.model.exchange.targetCurrency));return b.innerText=F.toFixed(2),b.classList.add(F.amount>0?"positive":"negative"),m.appendChild(b),e}}class te{constructor(e){this.model=e}render(){const e=document.createElement("div"),t=document.createElement("h2");t.innerText="Realized gain or loss for all years",e.appendChild(t);const n=this.model.executedTransactions,s=n.map(u=>u.time.getUTCFullYear()),i=Array.from(new Set(s)).sort((u,c)=>u-c);for(const u of i){const c=n.filter(a=>a.time.getUTCFullYear()===u);e.appendChild(new ee(this.model,u,c).render())}return e}}async function ne(r,e,t){const n=r.transactions.sort((u,c)=>u.time.getTime()-c.time.getTime()),s=await K(e,n,t),i=re(n);return r.warnings.push(...i),{file:r,executedTransactions:n,exchange:s}}function re(r){const e=r.filter(n=>w.includes(n.type)),t=[];for(const n of e){const s=r.filter(a=>x.includes(a.type)&&a.asset===n.asset&&a.time<n.time&&Math.abs(a.quantitySold-a.quantity)>J);let i=n.quantity,u=new l(0,n.priceCurrency),c=new l(0,n.priceCurrency);for(const a of s){const o=Math.min(a.quantity-a.quantitySold,i);if(a.quantitySold+=o,u=u.plus(a.total.multiply(o/a.quantity)),c=c.plus(a.fee.multiply(o/a.quantity)),i-=o,i===0)break}n.price.amount*i>.05&&t.push(`Unable to find the buy for ${i} ${n.asset} in ${n.raw} - gains can be overstated by ${n.price.multiply(i).toFixed(2)}`),n.gainOrLoss=n.total.minus(u),n.lossInFeesIncluded=n.fee.plus(c)}return t}function se(r){let e=0;for(const t of r)W.includes(t.type)?e+=t.quantity:E.includes(t.type)&&(e-=t.quantity);return e}class ie{constructor(e,t,n){C(this,"firstTransaction");C(this,"priceCurrency");C(this,"headers");C(this,"needsCurrencyConversion",!1);if(this.groupKey=e,this.transactions=t,this.exchange=n,t.length===0)throw new Error("No transactions provided for "+e);this.firstTransaction=t[0],this.priceCurrency=this.firstTransaction.priceCurrency,this.needsCurrencyConversion=Z(t,this.exchange.targetCurrency),this.headers=["Time","Type",`Quantity ${this.firstTransaction.asset}`,`Price ${y(this.priceCurrency)}`],this.needsCurrencyConversion&&this.headers.push(`Price ${y(this.exchange.targetCurrency)}`),this.headers.push(`Fee ${y(this.priceCurrency)}`),this.needsCurrencyConversion&&this.headers.push(`Fee ${y(this.exchange.targetCurrency)}`),this.headers.push(`Total ${y(this.priceCurrency)}`),this.needsCurrencyConversion&&this.headers.push(`Total ${y(this.exchange.targetCurrency)}`),this.headers.push(`Gain ${y(this.priceCurrency)}`),this.needsCurrencyConversion&&this.headers.push(`Gain ${y(this.exchange.targetCurrency)}`)}renderGroup(){const e=document.createElement("div");if(e.classList.add("transactionGroup"),this.transactions.length===0)return e;this.transactions.sort((n,s)=>n.time.getTime()-s.time.getTime()),e.dataset.sortKey=`${T.includes(this.firstTransaction.asset)||v.includes(this.firstTransaction.asset)?0:1}-${this.firstTransaction.asset}`,this.renderGroupHeader(e);const t=this.createTableStructure(e);return this.renderTableHeader(t),this.renderTableBody(t),this.renderTableFooter(t),this.renderGainLossByYear(e),e}renderGroupHeader(e){const t=document.createElement("h2");t.innerText=this.groupKey,t.id=this.firstTransaction.asset,e.appendChild(t)}createTableStructure(e){const t=document.createElement("table"),n=document.createElement("div");return n.classList.add("tableScroller"),n.appendChild(t),e.appendChild(n),t}renderTableHeader(e){const t=document.createElement("thead"),n=document.createElement("tr");t.appendChild(n),e.appendChild(t);for(const s of this.headers){const i=document.createElement("th");i.innerText=s,I(s)&&i.classList.add("numeric"),n.appendChild(i)}}renderTableBody(e){const t=T.includes(this.firstTransaction.asset)||v.includes(this.firstTransaction.asset)?1:-1;for(const n of this.transactions){const s=document.createElement("tr");s.title=n.raw,e.appendChild(s);const i=[n.time.toISOString().split("T")[0],n.type,n.quantity,n.price];this.needsCurrencyConversion&&i.push(n.price.convert(n.time,this.exchange)),i.push(n.fee),this.needsCurrencyConversion&&i.push(n.fee.convert(n.time,this.exchange));const u=n.total.multiply(t*(E.includes(n.type)?-1:1));i.push(u),this.needsCurrencyConversion&&i.push(u.convert(n.time,this.exchange)),i.push(n.gainOrLoss),this.needsCurrencyConversion&&i.push(n.gainOrLoss.convert(n.time,this.exchange));for(let c=0;c<i.length;c++){const a=i[c],o=document.createElement("td"),d=this.headers[c];a===0?o.innerText="":typeof a=="number"?(o.innerText=a.toFixed(d.startsWith("Price")&&Math.abs(a)<1e4?4:2),o.classList.add("numeric"),(d.startsWith("Total")||d.startsWith("Gain"))&&o.classList.add(a>0?"positive":"negative")):a instanceof l?(o.innerText=a.toFixed(d.startsWith("Price")&&Math.abs(a.amount)<1e4?4:2),o.classList.add("numeric"),(d.startsWith("Total")||d.startsWith("Gain"))&&o.classList.add(a.amount>0?"positive":"negative")):o.innerText=String(a),s.appendChild(o)}}}renderTableFooter(e){const t=document.createElement("tr");t.classList.add("totalRow"),e.appendChild(t),t.appendChild(this.createTd("Total")),t.appendChild(document.createElement("td"));const n=se(this.transactions);t.appendChild(this.createNumericTd(n,2,!1)),t.appendChild(document.createElement("td")),this.needsCurrencyConversion&&t.appendChild(document.createElement("td"));const s=this.transactions.reduce((a,o)=>a.plus(o.fee),new l(0,this.priceCurrency));if(t.appendChild(this.createMoneyTd(s)),this.needsCurrencyConversion){const a=this.transactions.reduce((o,d)=>o.plus(d.fee.convert(d.time,this.exchange)),new l(0,this.exchange.targetCurrency));t.appendChild(this.createMoneyTd(a))}const i=T.includes(this.firstTransaction.asset)||v.includes(this.firstTransaction.asset)?1:-1,u=this.transactions.reduce((a,o)=>a.plus(o.total.multiply((E.includes(o.type)?-1:1)*i)),new l(0,this.priceCurrency));if(t.appendChild(this.createMoneyTd(u)),this.needsCurrencyConversion){const a=this.transactions.reduce((o,d)=>o.plus(d.total.convert(d.time,this.exchange).multiply((E.includes(d.type)?-1:1)*i)),new l(0,this.exchange.targetCurrency));t.appendChild(this.createMoneyTd(a))}const c=this.transactions.reduce((a,o)=>a.plus(o.gainOrLoss.convert(o.time,this.exchange,this.priceCurrency)),new l(0,this.priceCurrency));if(t.appendChild(this.createMoneyTd(c)),this.needsCurrencyConversion){const a=this.transactions.reduce((o,d)=>o.plus(d.gainOrLoss.convert(d.time,this.exchange)),new l(0,this.exchange.targetCurrency));t.appendChild(this.createMoneyTd(a))}}renderGainLossByYear(e){const t=new Map,n=new Map;for(const a of this.transactions){if(a.gainOrLoss.amount===0)continue;const o=a.time.getUTCFullYear(),d=t.get(o)||new l(0,this.priceCurrency);if(t.set(o,d.plus(a.gainOrLoss)),this.needsCurrencyConversion){const m=n.get(o)||new l(0,this.exchange.targetCurrency);n.set(o,m.plus(a.gainOrLoss.convert(a.time,this.exchange)))}}if(t.size===0)return;e.appendChild(document.createElement("br"));const s=document.createElement("table");e.appendChild(s);const i=document.createElement("thead"),u=document.createElement("tr");i.appendChild(u),s.appendChild(i);const c=["Year",`Gain ${y(this.priceCurrency)}`];this.needsCurrencyConversion&&c.push(`Gain ${y(this.exchange.targetCurrency)}`);for(const a of c){const o=document.createElement("th");o.innerText=a,I(a)&&o.classList.add("numeric"),u.appendChild(o)}for(const[a,o]of t){const d=document.createElement("tr");if(s.appendChild(d),d.appendChild(this.createTd(String(a))),d.appendChild(this.createMoneyTd(o)),this.needsCurrencyConversion){const m=n.get(a)||new l(0,this.exchange.targetCurrency);d.appendChild(this.createMoneyTd(m))}}}createTd(e){const t=document.createElement("td");return t.innerText=e,t}createNumericTd(e,t,n){const s=document.createElement("td");return e&&(s.innerText=e.toFixed(t),s.classList.add("numeric"),n&&s.classList.add(e>0?"positive":"negative")),s}createMoneyTd(e){const t=document.createElement("td");t.innerText=e.toString(),t.classList.add("numeric"),t.classList.add(e.amount>0?"positive":"negative");debugger;return t}}class ae{constructor(e){this.model=e}render(){const e=document.createElement("div"),t=oe(this.model.executedTransactions),n=[];for(const[s,i]of t)n.push(new ie(s,i,this.model.exchange).renderGroup());return n.sort((s,i)=>s.dataset.sortKey.localeCompare(i.dataset.sortKey)),e.replaceChildren(...n),e}}function oe(r){const e=new Map;for(const t of r){const n=ce(t),s=e.get(n)||[];s.push(t),e.set(n,s)}return e}function ce(r){return r.type==="Deposit"||r.type==="Withdrawal"?"Deposit / Withdrawal":r.type==="Reward Income"?r.type:v.includes(r.asset)&&(x.includes(r.type)||w.includes(r.type))?`${r.asset} Trading`:T.includes(r.asset)?r.type:r.asset}const G=document.getElementById("transactionOutput"),ue=document.getElementById("calculateGainLoss"),M=document.getElementById("currencySelect");for(const r of T.concat().sort()){if(r==="USD")continue;const e=document.createElement("option");e.value=r,e.innerText=r,e.selected=r==="EUR",M.appendChild(e)}const q=document.getElementById("transactionInput");q.addEventListener("change",P);function P(){const r=q.files;if(!r)return;const e=r[0];if(!e)return;const t=new FileReader;t.onload=async()=>{try{await de(z(t.result))}catch(n){alert(`Error parsing file: ${n}`)}},t.onerror=n=>{alert(`Error reading file: ${n}`)},t.readAsText(e)}P();async function de(r){const e=await ne(r,le(),t=>{G.innerText=t});G.replaceChildren(new _().render(e),new te(e).render(),new ae(e).render())}function le(){return ue.checked&&M.value||"USD"}

</script>
  <style>
html{padding:0;margin:0}body{font-family:Roboto;padding:0 20px;max-width:1000px;margin:0 auto 50px}.error{color:red;padding-bottom:10px}.warning{color:#ff9100;padding-bottom:10px}table{border-collapse:collapse}.yearSecurityTable{width:100%}th,td{padding:5px;border:1px solid #ddd;text-align:left;min-width:50px}th,.totalRow{background-color:#f2f2f2;font-weight:700}.numeric{text-align:right}.positive{color:green;text-align:right}.negative{color:red;text-align:right}

</style>
</head>

<body>
  <h1>📖 coinbuch</h1>
  <p>
    Open-source tool for analysing Coinbase transaction log.
    <a href="https://github.com/kachurovskiy/coinbuch/">Learn more on GitHub</a>
  </p>
  <p>
    <label>
      <input type="checkbox" id="calculateGainLoss" />
      Calculate Gain in another currency
    </label>
    <label for="currencySelect">Currency:</label>
    <select id="currencySelect"></select>
  </p>
  <p>
    Transactions CSV from <a href="https://accounts.coinbase.com/statements">accounts.coinbase.com/statements</a>: <input type="file" id="transactionInput" accept=".csv"/>
  </p>
  <div id="transactionOutput"></div>
  
</body>

</html>
